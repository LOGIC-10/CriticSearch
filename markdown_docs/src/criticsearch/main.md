## FunctionDef flatten_outline(section, depth, path)
**flatten_outline**: The function of flatten_outline is to flatten a hierarchical outline structure into a list of sections, each annotated with its depth and path.

**parameters**: The parameters of this Function.
· section: A dictionary representing a section of the outline, which may contain a title and potentially a list of child sections.
· depth: An integer indicating the current depth level in the hierarchy, defaulting to 1.
· path: A list that tracks the path of titles leading to the current section, defaulting to None.

**Code Description**: The flatten_outline function takes a section of an outline and recursively flattens it into a list of dictionaries. Each dictionary in the resulting list contains the following keys: "path", "section", and "depth". The "path" key holds a list of titles leading to the current section, the "section" key contains the original section data, and the "depth" key indicates how deep the section is in the hierarchy.

Initially, if the path is not provided, it is set to an empty list. The function constructs a dictionary for the current section, appending its title to the path and setting its depth. This dictionary is added to a list called flat. If the current section has children, the function iterates over each child, calling itself recursively with the child section, incrementing the depth by one, and updating the path to include the current section's title. The results from these recursive calls are then extended into the flat list.

This function is called within the process_single_task function, where it is used to flatten an outline generated by a benchmark report. The flattened outline is essential for generating content for each section in parallel, allowing for efficient processing of multiple sections at once. The flattened structure enables the system to maintain the context of each section while generating content, ensuring that the generated report is coherent and well-structured.

**Note**: It is important to ensure that the input section is correctly formatted as a dictionary with the expected keys ("title" and "children") to avoid errors during execution. The function assumes that the outline follows a specific structure, and deviations from this structure may lead to unexpected results.

**Output Example**: An example output of the flatten_outline function might look like this for a given outline:

```json
[
    {
        "path": ["Introduction"],
        "section": {"title": "Introduction", "children": [...]},
        "depth": 1
    },
    {
        "path": ["Introduction", "Background"],
        "section": {"title": "Background", "children": [...]},
        "depth": 2
    },
    {
        "path": ["Introduction", "Background", "Details"],
        "section": {"title": "Details", "children": []},
        "depth": 3
    }
]
``` 

This output illustrates how the function captures the hierarchical structure of the outline while providing a flat representation that can be easily processed for content generation.
## FunctionDef generate_content_for_section(common_agent, section, task)
**generate_content_for_section**: The function of generate_content_for_section is to generate detailed content for a specific section based on a given task and title.

**parameters**: The parameters of this Function.
· common_agent: An instance of a class that facilitates interactions with various agents, including searching and chatting functionalities.
· section: A dictionary containing information about the section, specifically its title.
· task: A string that represents the overarching topic or task under which the section content is to be generated.

**Code Description**: The generate_content_for_section function is designed to create content for a specific section of a report or document. It begins by extracting the title from the provided section dictionary. Using this title, it formulates a search query that instructs the common_agent to generate relevant search queries related to the title within the context of the specified task. The search query is structured to prompt the agent to gather information that will be used to construct the content.

The function then calls the common_agent's search_and_browse method with the formulated search query, which retrieves search results. These results are then incorporated into a prompt that instructs the agent to write one or several detailed paragraphs about the section title, ensuring that the content is logically structured and includes citations for any data sourced from the web. The prompt explicitly requests that the output be formatted in plain text without summary sentences, and it emphasizes the importance of including citations in a specified format.

After constructing the prompt, the function invokes the common_agent's common_chat method to generate the actual content based on the prompt. The generated paragraph is then printed to the console using the printer's print method, preceded by a horizontal rule that indicates the section for which content has been generated. Finally, the function returns the generated paragraph.

This function is called within the process_single_task function, which orchestrates the overall task processing. In process_single_task, the generate_content_for_section function is executed in parallel for multiple sections of a report, utilizing a ThreadPoolExecutor to manage concurrent execution. This allows for efficient generation of content across different sections, enhancing the overall performance of the task.

**Note**: When using the generate_content_for_section function, it is crucial to ensure that the common_agent is properly initialized and capable of performing search and chat operations. Additionally, the section parameter must contain a valid title to generate meaningful content.

**Output Example**: A possible return value of the function could be a detailed paragraph such as: "The Syrian opposition has undergone significant transformations since the onset of the civil war. Various factions have emerged, each with distinct ideologies and objectives. According to <cite>https://example.com/source</cite>, the fragmentation of the opposition has complicated efforts for a unified front against the regime. Furthermore, the international community's involvement has influenced the dynamics on the ground, as noted by <cite>https://example.com/another-source</cite>."
## FunctionDef reconstruct_markdown(outline, flat_contents)
### Function: `reconstruct_markdown`

#### Overview:
The `reconstruct_markdown` function generates a Markdown formatted text from an outline structure and a set of flattened content. It uses the provided outline's structure, iterating through each section, and then associates the content from the flat list based on the full path of each section to ensure the correct order and content placement. The result is a well-structured Markdown document that preserves the hierarchical organization of the sections.

#### Parameters:
- **outline (dict)**: A dictionary representing the hierarchical structure of the document. This outline contains keys such as "title" for section titles, and "children" for sub-sections. The structure represents the sections and subsections in a nested manner.
  
- **flat_contents (list of tuples)**: A list of tuples where each tuple contains an item (a dictionary with a key "path" representing the unique path to the section) and its associated content. The content for each section is mapped to its full path, ensuring that the correct content is placed in the respective section.

#### Return:
- **str**: A string containing the reconstructed Markdown content. The structure follows the outline's hierarchy, with the correct content inserted under each section title. The content is formatted using Markdown syntax, with headings marked by `#` corresponding to the section depth.

#### Description:
1. **Mapping Content to Paths**:  
   The function starts by creating a dictionary (`content_map`) that maps a unique path (represented as a tuple of section titles) to its corresponding content. This ensures that each section's content is correctly aligned with the section’s path in the outline.

2. **Recursive Helper Function**:  
   A recursive helper function (`helper`) is defined to traverse the outline. For each section, it:
   - Constructs the path by appending the current section's title to the path of its parent.
   - Generates the appropriate heading for the section based on its depth in the hierarchy (using the number of titles in the path to determine the heading level).
   - Checks if the section has corresponding content in the `content_map` and adds it to the Markdown output if available.
   - Recursively processes child sections if they exist.

3. **Result Construction**:  
   The function starts by adding the title of the root section (if available) to the Markdown output. Then, it iterates through each section in the outline’s children and invokes the helper function to build the full document.

#### Example Usage:

```python
outline = {
    "title": "Main Title",
    "children": [
        {
            "title": "Section 1",
            "children": []
        },
        {
            "title": "Section 2",
            "children": [
                {"title": "Subsection 2.1", "children": []}
            ]
        }
    ]
}

flat_contents = [
    ({"path": ["Main Title", "Section 1"]}, "Content for Section 1"),
    ({"path": ["Main Title", "Section 2"]}, "Content for Section 2"),
    ({"path": ["Main Title", "Section 2", "Subsection 2.1"]}, "Content for Subsection 2.1")
]

markdown_text = reconstruct_markdown(outline, flat_contents)
print(markdown_text)
```

#### Output:

```markdown
# Main Title

## Section 1

Content for Section 1

## Section 2

### Subsection 2.1

Content for Subsection 2.1

Content for Section 2
```

#### Notes:
- The function ensures that the Markdown content is structured hierarchically, with section titles prefixed by the appropriate number of `#` characters based on their depth in the outline.
- The path-based content mapping ensures that even deeply nested sections receive their correct content, avoiding misalignment in the final document.

### FunctionDef helper(section, path)
**helper**: The function of helper is to recursively generate a Markdown representation of a structured document based on the provided section and its children.

**parameters**: The parameters of this Function.
· parameter1: section - A dictionary representing a section of the document, which includes a title and potentially child sections.
· parameter2: path - A list that keeps track of the current path of titles leading to the current section, defaulting to an empty list.

**Code Description**: The helper function constructs a Markdown string for a given section of a document. It begins by creating a new path that includes the title of the current section. This path is converted into a tuple, which serves as a key to look up content in a predefined `content_map`. The depth of the current section is determined by the length of the path, which is used to format the section title with the appropriate number of hash symbols for Markdown headers.

If the current section's path key exists in the `content_map`, the corresponding content is appended to the Markdown string. The function then checks if the section contains any child sections. If so, it iterates through each child and recursively calls itself, appending the resulting Markdown from each child to the current Markdown string. Finally, the complete Markdown string for the section and its children is returned.

**Note**: It is important to ensure that the `content_map` is defined and contains the necessary content for the sections being processed. The function assumes that the structure of the input section is consistent and that each section may have a "title" and optionally "children".

**Output Example**: An example output for a section with the title "Introduction" and a child section titled "Background" might look like this:

```
# Introduction

This is the content for the Introduction section.

## Background

This is the content for the Background section.
```
***
## FunctionDef extract_citations(text)
**extract_citations**: The function of extract_citations is to extract URLs enclosed within <cite> tags from a given text.

**parameters**: The parameters of this function are as follows:
· text: A string containing the text from which citations are to be extracted.

**Code Description**: The extract_citations function utilizes a regular expression to identify and extract all occurrences of text that are enclosed within <cite> tags in the provided input text. It initializes an empty list called citations to store the matched URLs. The regular expression pattern defined as r"<cite>(.*?)<\/cite>" is used to find all matches in the text. The re.findall function is then employed to search for all occurrences of this pattern, returning a list of matches. This list is subsequently returned as the output of the function.

The extract_citations function is called within two other functions in the project: process_section and parse_markdown_to_structure. In process_section, it is used to extract citations from paragraphs of text that are processed from a section of a document. Each paragraph is checked for citations, and any found are added to the corresponding section data structure. Similarly, in parse_markdown_to_structure, the function is called to extract citations from paragraphs collected while parsing markdown text into a structured format. This indicates that extract_citations plays a crucial role in ensuring that any citations present in the text are captured and organized appropriately within the document structure.

**Note**: It is important to ensure that the input text contains properly formatted <cite> tags for the function to work effectively. If the tags are malformed or absent, the function will return an empty list.

**Output Example**: An example of the function's return value could be: ['http://example.com/citation1', 'http://example.com/citation2'] if the input text contained the following: "Here is a reference <cite>http://example.com/citation1</cite> and another one <cite>http://example.com/citation2</cite>."
## FunctionDef create_document_structure(outline_json, flat_contents)
**create_document_structure**: The function of create_document_structure is to create a structured document based on an outline and associated content.

**parameters**: The parameters of this Function.
· outline_json: A JSON object representing the outline structure of the document, including titles and hierarchical relationships.
· flat_contents: A list of tuples, where each tuple contains an item (with a path) and its corresponding content as a string.

**Code Description**: The create_document_structure function constructs a document structure by utilizing the provided outline and content. It initializes a document dictionary with a title and a level, setting up a place for subsections. The function then creates a mapping of content to paths derived from the flat_contents parameter, allowing for easy retrieval of content based on the section paths.

The core of the function is the nested process_section function, which recursively processes each section of the outline. It constructs a section_data dictionary that includes the title, level, and paragraphs for each section. If content exists for a given path, it splits the content into paragraphs based on double newlines, ignoring any empty paragraphs. Each paragraph is processed to extract citations, which are stored alongside the paragraph text.

The function also handles child sections by recursively calling process_section for each child, appending the resulting data to the current section's subsections. Finally, the function iterates through the root sections of the outline, processing each one and appending it to the main document structure before returning the complete document.

**Note**: It is important to ensure that the outline_json is well-structured and that the flat_contents accurately corresponds to the paths defined in the outline. The function assumes that paragraphs are separated by double newlines and that citations can be extracted from the paragraphs.

**Output Example**: A possible appearance of the code's return value could be as follows:
{
    "document": {
        "title": "Sample Document Title",
        "level": 1,
        "subsections": [
            {
                "title": "Introduction",
                "level": 2,
                "paragraphs": [
                    {
                        "text": "This is the first paragraph of the introduction.",
                        "citations": ["Citation1", "Citation2"]
                    },
                    {
                        "text": "This is the second paragraph of the introduction.",
                        "citations": []
                    }
                ],
                "subsections": []
            },
            {
                "title": "Methodology",
                "level": 2,
                "paragraphs": [],
                "subsections": []
            }
        ]
    }
}
### FunctionDef process_section(section, depth, path)
**process_section**: The function of process_section is to recursively process a section of a document, extracting its title, paragraphs, and any nested subsections.

**parameters**: The parameters of this Function are as follows:
· section: A dictionary representing a section of the document, which includes a title and potentially child sections.
· depth: An integer indicating the current depth of the section in the document hierarchy, defaulting to 1.
· path: A list that tracks the path of titles leading to the current section, defaulting to an empty list.

**Code Description**: The process_section function begins by constructing the current path of titles by appending the title of the current section to the existing path. This path is then converted into a tuple, which serves as a key to access content from a predefined content_map. The function initializes a dictionary, section_data, to store the title, depth level, and an empty list for paragraphs.

If the current path key exists in the content_map, the function retrieves the associated content and splits it into paragraphs based on double newlines, assuming that paragraphs are separated by empty lines. Each paragraph is processed to extract citations using the extract_citations function, which identifies URLs enclosed within <cite> tags. Non-empty paragraphs are added to the section_data dictionary, along with their corresponding citations.

The function then checks if the current section has any child sections. If so, it initializes a list for subsections and recursively calls process_section for each child, incrementing the depth by one and passing the updated path. Each child's processed data is appended to the subsections list within section_data.

Finally, the function returns the constructed section_data dictionary, which encapsulates the processed information of the section, including its title, depth, paragraphs, and any nested subsections.

This function is integral to the overall structure of the document processing system, as it organizes sections and their content into a structured format. It relies on the extract_citations function to ensure that citations are accurately captured and associated with their respective paragraphs.

**Note**: It is essential that the content_map contains properly formatted entries corresponding to the section titles for the function to retrieve and process content effectively. If the section does not have associated content or if the structure of the input data is incorrect, the function may return incomplete or empty section data.

**Output Example**: An example of the function's return value could be:
{
    "title": "Introduction",
    "level": 1,
    "paragraphs": [
        {
            "text": "This is the first paragraph of the introduction.<cite>http://example.com/citation1</cite>",
            "citations": ["http://example.com/citation1"]
        },
        {
            "text": "This is the second paragraph of the introduction.",
            "citations": []
        }
    ],
    "subsections": [
        {
            "title": "Background",
            "level": 2,
            "paragraphs": [],
            "subsections": []
        }
    ]
}
***
## FunctionDef parse_markdown_to_structure(markdown_text)
## Function Documentation: `parse_markdown_to_structure`

### Overview

The `parse_markdown_to_structure` function is responsible for parsing a given markdown text and converting it into a structured document format. It organizes the markdown content into a hierarchical document structure, which includes titles, subsections, and paragraphs. Citations within paragraphs are also extracted and included in the structure.

### Parameters

- **markdown_text** (str): The input markdown text to be parsed. This should be a string containing the raw markdown content.

### Returns

- **document** (dict): A dictionary representing the parsed document structure. It contains the following keys:
  - **document**: The root level of the document, which includes:
    - **title**: The title of the document (empty string initially).
    - **level**: The level of the document (1 initially).
    - **subsections**: A list of subsections at this level.
  - **subsections**: A list of subsections for each heading found in the markdown text, with each subsection containing:
    - **title**: The title of the subsection.
    - **level**: The level of the subsection, corresponding to the number of `#` symbols in the markdown heading.
    - **paragraphs**: A list of paragraphs under the subsection.
    - **subsections**: Subsections under the current section.

### Description

The function performs the following tasks:

1. **Initial Setup**: 
   - It splits the input `markdown_text` into lines and initializes a dictionary (`document`) with a structure containing a title, level, and subsections.
   - It sets up a `section_stack` to keep track of the current section as the parsing progresses.

2. **Processing Lines**: 
   - The function iterates through each line of the markdown text:
     - **Handling Headings**: 
       - When a line starts with `#`, the function processes it as a heading. The number of `#` symbols in the heading determines the level of the subsection.
       - If there is any unprocessed paragraph text before encountering a heading, it is added as a paragraph under the current section.
       - The function adjusts the `section_stack` based on the heading level to ensure that subsections are nested correctly.
     - **Handling Paragraphs**: 
       - For lines that are not headings, the function accumulates them as paragraph text until a blank line is encountered or a new heading is found. When a paragraph is fully processed, the function extracts any citations within it and adds the paragraph to the current section.
   
3. **Finalizing Paragraphs**: 
   - After processing all lines, any remaining paragraph text is finalized and added to the document structure.

4. **Citation Extraction**:
   - Throughout the parsing process, the `extract_citations` function is called to extract any citations (URLs within `<cite>` tags) from the paragraph text.

### Example

#### Input:
```markdown
# Main Title

This is an introduction paragraph with a citation <cite>http://example.com/citation1</cite>.

## Subsection 1

This is a paragraph under subsection 1 with another citation <cite>http://example.com/citation2</cite>.

### Subsubsection 1.1

Text in the subsubsection.
```

#### Output:
```python
{
  "document": {
    "title": "",
    "level": 1,
    "subsections": [
      {
        "title": "Main Title",
        "level": 1,
        "subsections": [
          {
            "title": "Subsection 1",
            "level": 2,
            "subsections": [
              {
                "title": "Subsubsection 1.1",
                "level": 3,
                "subsections": [],
                "paragraphs": [
                  {"text": "Text in the subsubsection.", "citations": []}
                ]
              }
            ],
            "paragraphs": [
              {"text": "This is a paragraph under subsection 1 with another citation http://example.com/citation2.", "citations": ["http://example.com/citation2"]}
            ]
          }
        ],
        "paragraphs": [
          {"text": "This is an introduction paragraph with a citation http://example.com/citation1.", "citations": ["http://example.com/citation1"]}
        ]
      }
    ]
  }
}
```

### Notes

- The function relies on the proper formatting of markdown headings (e.g., using `#` for titles) and paragraphs (text separated by blank lines).
- Citations are identified by the `extract_citations` function, which looks for URLs enclosed within `<cite>` tags in the text.
- The document structure is hierarchical, allowing for nested subsections and paragraphs.
## FunctionDef process_single_task(task, max_iterations)
**process_single_task**: The function of process_single_task is to execute a single task by interacting with various agents to generate a comprehensive report based on the provided task and specified maximum iterations.

**parameters**: The parameters of this Function.
· task: A string representing the task or question that the agent needs to process.
· max_iterations: An integer indicating the maximum number of iterations to perform while processing the task.

**Code Description**: The process_single_task function is designed to manage the execution of a specific task by coordinating interactions between multiple agents, including a common agent, a search aggregator, and a verifier. The function begins by initializing necessary components such as the common agent, search aggregator, and report verifier. It then loads a JSON file containing benchmark data, which is essential for generating the report.

The function processes the task iteratively, up to the specified maximum number of iterations. In each iteration, it assesses the confidence of the agent in its response and determines whether to generate a direct answer or to conduct a guided search based on the outline of the report. If the agent is confident, it provides a direct response; otherwise, it engages in a guided search to gather relevant information.

During the guided search, the function extracts thought processes and queries from the agent's responses, which are then used to perform web searches and scrape results. The generated content for each section of the report is constructed in parallel using a thread pool, allowing for efficient processing of multiple sections simultaneously. The function also incorporates a verification step, where the generated answers are checked against extracted facts to ensure accuracy.

The process_single_task function is called by the execute_multiple_tasks function, which handles the execution of multiple tasks in a loop. This integration allows for the systematic processing of each task, logging the conversation history for later review.

**Note**: It is important to ensure that the input task is well-defined and that the maximum iterations parameter is set appropriately to balance between thoroughness and efficiency. The function relies on the proper functioning of the agents and the availability of the JSON benchmark file to operate effectively.

**Output Example**: A possible return value from the process_single_task function could be a string summarizing the final report generated, such as:
```
"Based on the gathered information, the report concludes that the Syrian opposition has faced significant challenges in recent offensives, with various factions emerging and evolving over time."
```
