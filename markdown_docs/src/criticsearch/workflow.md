## ClassDef WorkflowExecutor
**WorkflowExecutor**: The function of WorkflowExecutor is to manage and execute a series of actions in a workflow, interacting with tools and generating responses based on the user's query and defined actions.

**attributes**:
· user_query: A string that contains the user's input query, which is used as the basis for generating the workflow.
· agent: An instance of the `BaseAgent` class responsible for managing tools and performing actions.
· registry: The registry of tools available to the agent, used to register and invoke tools.
· history: A list of interactions that keeps track of the conversation and system responses during the workflow execution.
· _step_count: A counter to track the number of steps executed in the workflow.
· _traj: A list that stores the trajectory of actions and rewards throughout the workflow.
· _last_obs: The last observation generated by the workflow execution.

**Code Description**:  
The `WorkflowExecutor` class is designed to facilitate the execution of a structured workflow that interacts with various tools to process the user's query. Upon initialization, the `WorkflowExecutor` takes a `user_query` as input, which sets the context for the workflow execution. The class performs the following functions:

- **Initialization**:
  - The `__init__` method creates an instance of the `BaseAgent` class and retrieves the tool registry (`self.registry`) to manage available tools.
  - A unique session ID is generated using `uuid.uuid4()` and set using `set_session()` to track the session for note-taking and reporting purposes.
  - The tools used in the workflow are registered, including functions such as `search`, `scrape`, note-taking (`taking_notes`), and retrieving notes (`retrieve_notes`).
  - A schema for each tool is generated by querying the tool registry, which defines the available tools and their arguments.
  - A system prompt is loaded and rendered using a template from a file, incorporating the available tools and the user query into the prompt.
  - The history is initialized to track the conversation between the system and user, including the system's initial prompt and the user query.
  - The step counter (`_step_count`) and trajectory list (`_traj`) are initialized to track the execution progress.

- **Step Execution**:
  - The `step` method is responsible for executing a single step in the workflow, processing an action and interacting with the tools. This method receives an action, processes it, and returns a tuple containing the observation, reward, completion status, and additional information.
  - The action is evaluated to determine if it involves a tool invocation. If the action includes a tool call (identified via an XML tag), the tool's name and arguments are extracted, and the tool is invoked through the registry.
  - The result of the tool invocation is returned as an observation, and the trajectory of actions and rewards is updated.
  - If the action does not involve a tool invocation (i.e., it is the final answer), the workflow ends with the final response being returned, along with a reward.
  - Error handling is implemented to return an error response if the tool invocation or argument parsing fails.

The `WorkflowExecutor` class is utilized in the `run_workflow` and `iterate_traj` functions. In `run_workflow`, the executor is instantiated with the user's query, and the workflow progresses by repeatedly calling the `step` method until the workflow is completed. In `iterate_traj`, the executor is used to process sections of a report, iterating through each section and evaluating its factual accuracy.

**Note**:  
- Ensure that the user query provided to the `WorkflowExecutor` is well-defined, as it influences the entire workflow execution.
- The tool registry and system prompt are critical components for successful execution, as they define the tools available and the context in which the workflow operates.
- The class maintains a history of interactions and tracks the trajectory of actions, which can be useful for debugging or analyzing the workflow.
- The class performs error handling during tool invocation and argument parsing, ensuring that invalid actions are managed gracefully.

**Output Example**:  
A typical output of the `step` method could look like this:
```
{
    "observation": "<tool_use_result><name>search</name><result>{'found_results': 5}</result></tool_use_result>",
    "reward": 0.0,
    "done": False,
    "info": {}
}
```
This output includes the tool result (`observation`), the reward (`reward`), a flag indicating whether the process is complete (`done`), and any additional information (`info`).
### FunctionDef __init__(self, user_query)
**__init__**: The function of __init__ is to initialize the WorkflowExecutor class, setting up the agent, registry, session, and conversation history.

**parameters**: The parameters of this Function.
· user_query: str - A string representing the user's query that will be processed by the WorkflowExecutor.

**Code Description**: The __init__ method is the constructor for the WorkflowExecutor class. It is responsible for initializing various components necessary for the execution of workflows related to user queries. Upon instantiation, the method performs several key actions:

1. **Agent and Registry Initialization**: The method creates an instance of the BaseAgent class, which serves as the foundational class for intelligent agents. This instance is assigned to the `self.agent` attribute, and its tool registry is accessed through `self.registry`.

2. **Session Management**: A unique session identifier is generated using `uuid.uuid4()`, which ensures that each session is distinct. This session ID is then set using the `set_session` function, allowing for the binding of notes and other session-specific data to the current workflow.

3. **Tool Registration and Schema Generation**: The method defines a list of tool functions that the agent can utilize, including search aggregation, content scraping, note-taking, and note retrieval functions. For each of these functions, the method retrieves or creates their corresponding schemas by calling `self.registry.get_or_create_tool_schema(func)`. This ensures that the tools are properly registered and ready for use in the workflow.

4. **System Prompt Loading and Rendering**: The method loads a system prompt template from a specified file path and renders it using the user query and the available tool schemas. This rendered prompt is stored in the `system_prompt` variable and is included in the conversation history.

5. **Conversation History Initialization**: The method initializes the conversation history with the system prompt and the user's query. It also sets the step count to zero and initializes an empty trajectory list, which may be used to track the execution steps of the workflow.

The __init__ method establishes the foundational setup for the WorkflowExecutor, ensuring that all necessary components are in place for processing user queries effectively. It integrates various functionalities from the BaseAgent class and other tools, enabling a seamless workflow execution process.

**Note**: It is important to ensure that the user_query parameter is valid and properly formatted, as it directly influences the rendering of the system prompt and the subsequent workflow execution. Additionally, the tool registry must be populated with the necessary tools before invoking methods that rely on them.
***
### FunctionDef step(self, action)
**step**: The function of step is to execute a specified action, record the process, and return the resulting observation, reward, completion status, and additional information.

**parameters**: The parameters of this Function.
· action: A string representing the action to be executed, which may involve tool usage or provide a final answer.

**Code Description**: The step function is a core component of the WorkflowExecutor class, responsible for processing an action provided as input. Upon invocation, it increments the step count and appends the action to the history log. The function then attempts to extract any tool usage information from the action string using the extract_tag_content function. If no tool usage is detected, the function treats the action as a final answer, assigns a reward of 1, and sets the done flag to True, indicating the completion of the workflow.

If tool usage is identified, the function extracts the tool's name and its arguments. It attempts to parse the arguments from a JSON string. If parsing fails, an error message is generated and returned, along with an invalid penalty as the reward. If the arguments are successfully parsed, the function invokes the specified tool using the ToolRegistry's invoke_tool method. The result of the tool invocation is formatted into an XML structure and logged in the history. The function then returns the result, a reward of 0.0, and a done flag set to False, indicating that the workflow is still ongoing.

The step function is called within the run_workflow function, which orchestrates the overall workflow by continuously prompting the assistant for actions until a final answer is obtained. Additionally, it is utilized in the iterate_traj function, where it processes actions in the context of evaluating sections of a report against extracted facts.

**Note**: It is crucial to ensure that the action string is well-formed and contains valid tool usage information when applicable. If the tool name is not registered in the ToolRegistry, a KeyError will be raised during the invocation process. Furthermore, the arguments must be correctly formatted as a JSON string to avoid parsing errors.

**Output Example**: A possible return value from the step function could be:
```
("Final answer content", 1.0, True, {})
```
***
## FunctionDef run_workflow(user_query)
**run_workflow**: The function of run_workflow is to execute a workflow based on a user query, utilizing a WorkflowExecutor to manage the interaction and actions until a final response is obtained.

**parameters**: The parameters of this Function.
· user_query: A string that represents the user's input query, which serves as the basis for the workflow execution.

**Code Description**: The run_workflow function is designed to facilitate the execution of a structured workflow that processes a user query. Upon invocation, it initializes an instance of the WorkflowExecutor class, passing the user_query as an argument. The WorkflowExecutor is responsible for managing the workflow, including the interaction with tools and the generation of responses based on the user's input.

The function enters a continuous loop where it interacts with the WorkflowExecutor to obtain the next action suggested by the assistant. This is achieved by calling the chat method of the agent within the WorkflowExecutor, which processes the current history of interactions and generates a response. The response is then passed to the step method of the WorkflowExecutor, which executes the action and returns an observation, reward, completion status, and additional information.

The loop continues until the step method indicates that the workflow is complete by returning a done flag set to True. At this point, the function exits the loop and returns the history of interactions maintained by the WorkflowExecutor. This history includes all exchanges between the user and the assistant throughout the workflow, providing a comprehensive record of the process.

The run_workflow function is called within the main function of the project, where it can handle either a single user query or multiple queries concurrently. In the case of multiple queries, the function utilizes a ThreadPoolExecutor to manage concurrent execution, allowing for efficient processing of multiple workflows in parallel.

**Note**: It is essential to ensure that the user_query parameter is well-defined, as it directly influences the workflow execution. The WorkflowExecutor maintains a history of interactions, which can be useful for debugging or analyzing the workflow's performance.

**Output Example**: A possible appearance of the code's return value when calling the run_workflow function might look like this:
```
[
    {"role": "system", "content": "System prompt based on user query."},
    {"role": "user", "content": "User's input query."},
    {"role": "assistant", "content": "Assistant's response based on the query."},
    ...
]
```
## FunctionDef iterate_traj
**iterate_traj**: The function of iterate_traj is to evaluate a single section's factual accuracy as reward.

**parameters**: The parameters of this Function.
· None

**Code Description**: The iterate_traj function is designed to evaluate the factual accuracy of various sections of a report by generating content based on user prompts and verifying it against extracted facts. The function begins by initializing an instance of the BaseAgent class, which serves as the core component for managing interactions and processing user queries.

The function then attempts to load a JSON mapping file that contains user prompts associated with specific sections of the report. If the mapping file cannot be loaded, the function issues a warning and returns a default reward of 0.0. The mapping is essential as it provides the context for generating content for each section.

Next, the function iterates over the mapping items, where each item consists of a filename and a corresponding user prompt. For each section, it checks if the associated JSON file exists in the benchmark directory. If the file is missing, a warning is printed, and the function continues to the next section.

For each valid section, the function creates an instance of the ReportBenchmark class, passing the path to the JSON file and the user prompt. This instance is responsible for generating benchmark items, which include the section content and extracted facts. The benchmark items are generated using the generate_benchmark_item method, which may utilize caching to improve performance.

The function then constructs a full prompt for the section generation, which includes the user prompt, the section title, and any previously generated content for context. This prompt is passed to an instance of the WorkflowExecutor class, which manages the execution of actions and interactions with the agent.

Within a loop, the function engages in a conversation with the agent, sending the constructed prompt and receiving responses until a final answer is obtained. The response is processed to extract the section content, which is then verified against the extracted facts using the ReportVerifier class. The verification process evaluates the accuracy of the generated content and assigns a reward based on the results.

Finally, the function yields the trajectory of actions and rewards for each section, allowing for further analysis or processing. This iterative approach enables the evaluation of multiple sections in a structured manner, providing insights into the factual accuracy of the generated content.

**Note**: It is important to ensure that the mapping file and associated JSON files are correctly formatted and accessible. The function relies on the successful execution of the ReportBenchmark and ReportVerifier classes to generate and verify content accurately.

**Output Example**: A possible appearance of the code's return value when iterating through sections might look like this:
```json
[
    {
        "full_prompt": "User prompt...\nNow, based on the background information above, do not generate a complete report, but instead generate the content of the section I am requesting. The section you need to generate currently is: Section Title\n...",
        "section_content": "Generated content for the section...",
        "section_traj": [...],
        "section_reward": 0.85
    },
    ...
]
```
## FunctionDef main
**main**: The function of main is to execute a workflow based on user queries, allowing for both single and concurrent processing.

**parameters**: The parameters of this Function.
· query: A string representing a single user query to process.
· queries: A list of strings representing multiple user queries to process concurrently.
· workers: An integer specifying the maximum number of concurrent workers.
· count: An integer indicating the number of identical runs to perform if a single query is provided.

**Code Description**: The main function serves as the entry point for executing workflows based on user input. It utilizes the argparse library to parse command-line arguments, allowing users to specify either a single query or multiple queries for processing. The function requires at least one of the query options to be provided.

Upon parsing the arguments, the function determines the list of queries to be processed. If multiple queries are specified, it uses a ThreadPoolExecutor to manage concurrent execution of the workflows. The maximum number of workers is limited by either the user-specified value or the number of queries, whichever is smaller.

For each query, the function submits a task to the executor, which calls the run_workflow function. This function is responsible for executing the workflow based on the provided user query. The results of each workflow execution are collected in a dictionary, where the keys are the original queries and the values are the corresponding histories of interactions.

Once all futures are completed, the function outputs the complete history for each query in a formatted JSON structure. Additionally, it extracts and displays the final responses from the assistant for each query, providing a summary comparison of the results.

In the case where only a single query is provided, the function directly calls run_workflow and prints the resulting history.

The relationship with the run_workflow function is crucial, as it handles the core logic of executing the workflow based on user queries. The main function orchestrates the input handling and manages the concurrent execution of multiple workflows, leveraging the capabilities of run_workflow to obtain the necessary results.

**Note**: It is important to ensure that the command-line arguments are correctly specified when invoking the main function, as improper usage may lead to errors or unexpected behavior. The function is designed to handle both single and multiple queries efficiently, making it versatile for various use cases.
